---
layout:     post
title:     Binder通信驱动
subtitle:    底层探究
date:       2020-04-08
author:     BY
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - android
    - 驱动
    - Linux
    - Binder
    - ipc通信
---
##### binder底层源码来源
     当然是github官网linux源码目录：[linux内核binder驱动目录](https://github.com/torvalds/linux/tree/master/drivers/android)
    + biner.c
    + binder_alloc.c
    + binder_alloc.h
    + ...
#### 何为“驱动”
    （英语：device driver），简称驱动程序（driver），是一个允许高端（High level）电脑软件（computer software）与硬件（hardware）交互的程序，这种程序创建了一个硬件与硬件，或硬件与软件沟通的接口，经由主板上的总线（bus）或其它沟通子系统（subsystem）与硬件形成连接的机制，这样的机制使得硬件设备（device）上的数据交换成为可能。

     依据不同的计算机体系结构与操作系统差异平台，驱动程序经历了8位（8-bit）、16位（16-bit）、32位（32-bit）、64位（64-bit）变迁，这是为了调和操作系统与驱动程序之间的依存关系，例如在Windows 3.11的16位操作系统时代，大部分的驱动程序都是16位，到了32位的Windows XP则使用32位驱动程序（微软提供了Windows Driver Model可实现driver），至于64位的Linux或是Windows平台上，就必须使用64位的驱动程序（WDM与WDF皆可实现64位驱动程序）。来源：[维基百科](https://zh.wikipedia.org/wiki/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F)
###### 基于linux驱动基本类型
+ 字符设备（binder驱动就是此类型号，处理内存操作)
+ 块设备 
+ 网络接口
###### binder驱动概述
binder驱动是基于openbinder，专为android而用，与其他linux驱动架构一样，是以[misc]()设备进行注册，是*虚拟的字符设备*,不直接操作硬件，只是对设备内存处理。主要有以下功能：
+ 驱动设备的初始化(binder_init)
+ 打开驱动(binder_open)：每个应用只打开一次binder驱动，依稀记得是在[Zygote启动]()这个老祖宗里面有个打开binder线程池
+ 映射(binder_mmap)：这是binder-ipc通信只复制一次的关键
+ 内存读写操作(binder_ioctl)：前边铺垫就是为了这一步，这也是ipc的核心操作
###### binder_init
   '
static int __init binder_init(void)
{
	int ret;
	char *device_name, *device_tmp;
	struct binder_device *device;
	struct hlist_node *tmp;
	char *device_names = NULL;

	ret = binder_alloc_shrinker_init();
	if (ret)
		return ret;

	atomic_set(&binder_transaction_log.cur, ~0U);
	atomic_set(&binder_transaction_log_failed.cur, ~0U);

	binder_debugfs_dir_entry_root = debugfs_create_dir("binder", NULL);
	if (binder_debugfs_dir_entry_root)
		binder_debugfs_dir_entry_proc = debugfs_create_dir("proc",
						 binder_debugfs_dir_entry_root);

	if (binder_debugfs_dir_entry_root) {
		debugfs_create_file("state",
				    0444,
				    binder_debugfs_dir_entry_root,
				    NULL,
				    &binder_state_fops);
		debugfs_create_file("stats",
				    0444,
				    binder_debugfs_dir_entry_root,
				    NULL,
				    &binder_stats_fops);
		debugfs_create_file("transactions",
				    0444,
				    binder_debugfs_dir_entry_root,
				    NULL,
				    &binder_transactions_fops);
		debugfs_create_file("transaction_log",
				    0444,
				    binder_debugfs_dir_entry_root,
				    &binder_transaction_log,
				    &binder_transaction_log_fops);
		debugfs_create_file("failed_transaction_log",
				    0444,
				    binder_debugfs_dir_entry_root,
				    &binder_transaction_log_failed,
				    &binder_transaction_log_fops);
	}

	if (!IS_ENABLED(CONFIG_ANDROID_BINDERFS) &&
	    strcmp(binder_devices_param, "") != 0) {
		/*
		* Copy the module_parameter string, because we don't want to
		* tokenize it in-place.
		 */
		device_names = kstrdup(binder_devices_param, GFP_KERNEL);
		if (!device_names) {
			ret = -ENOMEM;
			goto err_alloc_device_names_failed;
		}

		device_tmp = device_names;
		while ((device_name = strsep(&device_tmp, ","))) {
			ret = init_binder_device(device_name);
			if (ret)
				goto err_init_binder_device_failed;
		}
	}

	ret = init_binderfs();
	if (ret)
		goto err_init_binder_device_failed;

	return ret;

err_init_binder_device_failed:
	hlist_for_each_entry_safe(device, tmp, &binder_devices, hlist) {
		misc_deregister(&device->miscdev);
		hlist_del(&device->hlist);
		kfree(device);
	}

	kfree(device_names);

err_alloc_device_names_failed:
	debugfs_remove_recursive(binder_debugfs_dir_entry_root);

	return ret;
}


'

解析：注意不同版本的内核代码有所不同，此处注意init_binder_device(bindername)方法
如下：详见--->[binder.c](https://github.com/torvalds/linux/blob/master/drivers/android/binder.c)


   'static int __init init_binder_device(const char *name)
{
	int ret;
	struct binder_device *binder_device;

	binder_device = kzalloc(sizeof(*binder_device), GFP_KERNEL);
	if (!binder_device)
		return -ENOMEM;

	binder_device->miscdev.fops = &binder_fops;
	binder_device->miscdev.minor = MISC_DYNAMIC_MINOR;
	binder_device->miscdev.name = name;

	refcount_set(&binder_device->ref, 1);
	binder_device->context.binder_context_mgr_uid = INVALID_UID;
	binder_device->context.name = name;
	mutex_init(&binder_device->context.context_mgr_node_lock);

	ret = misc_register(&binder_device->miscdev);
	if (ret < 0) {
		kfree(binder_device);
		return ret;
	}

	hlist_add_head(&binder_device->hlist, &binder_devices);

	return ret;
}'
 
'const struct file_operations binder_fops = {
	.owner = THIS_MODULE,
	.poll = binder_poll,
	.unlocked_ioctl = binder_ioctl,
	.compat_ioctl = compat_ptr_ioctl,
	.mmap = binder_mmap,
	.open = binder_open,
	.flush = binder_flush,
	.release = binder_release,
};'

注意“file_operations”结构体：
    Linux使用file_operations结构访问驱动程序的函数，这个结构的每一个成员的名字都对应着一个调用。
   用户进程利用在对设备文件进行诸如read/write操作的时候，系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理,代码结构体如下：参见[file_operation结构体](https://github.com/torvalds/linux/blob/master/include/linux/fs.h)
     '
struct file_operations { 
　　struct module *owner;//拥有该结构的模块的指针，一般为THIS_MODULES  
   loff_t (*llseek) (struct file *, loff_t, int);//用来修改文件当前的读写位置  
   ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);//从设备中同步读取数据   
   ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);//向设备发送数据  
   ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);//初始化一个异步的读取操作   
   ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);//初始化一个异步的写入操作   
　　int (*readdir) (struct file *, void *, filldir_t);//仅用于读取目录，对于设备文件，该字段为NULL   
   unsigned int (*poll) (struct file *, struct poll_table_struct *); //轮询函数，判断目前是否可以进行非阻塞的读写或写入   
　　int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long); //执行设备I/O控制命令   
　　long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); //不使用BLK文件系统，将使用此种函数指针代替ioctl  
　　long (*compat_ioctl) (struct file *, unsigned int, unsigned long); //在64位系统上，32位的ioctl调用将使用此函数指针代替   
　　int (*mmap) (struct file *, struct vm_area_struct *); //用于请求将设备内存映射到进程地址空间  
　　int (*open) (struct inode *, struct file *); //打开   
　　int (*flush) (struct file *, fl_owner_t id);   
　　int (*release) (struct inode *, struct file *); //关闭   
　　int (*fsync) (struct file *, struct dentry *, int datasync); //刷新待处理的数据   
　　int (*aio_fsync) (struct kiocb *, int datasync); //异步刷新待处理的数据   
　　int (*fasync) (int, struct file *, int); //通知设备FASYNC标志发生变化   
　　int (*lock) (struct file *, int, struct file_lock *);   
　　ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);   
　　unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);   
　　int (*check_flags)(int);   
　　int (*flock) (struct file *, int, struct file_lock *);  
　　ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);  
　　ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);   
　　int (*setlease)(struct file *, long, struct file_lock **);   
};
  '
此时注意下misc_register(....)方法，注册misc设备，何为[misc].()?
源码参见：[misc源码](https://github.com/torvalds/linux/blob/master/include/linux/miscdevice.h)
 
      '
        ....
struct miscdevice  {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};

extern int misc_register(struct miscdevice *misc);
extern void misc_deregister(struct miscdevice *misc);

        ....
'
[misc_register方法](https://github.com/torvalds/linux/blob/master/drivers/char/misc.c)
