---
layout:     post
title:      android 系统启动
subtitle:    源码分析启动流程
date:       2020-05-06
author:     wqq
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - android
    - 系统启动
    - native
    - Binder 
    - c
---
#### 安卓系统的今生前世
> Android is a mobile operating system based on a modified version of the Linux kernel and other open source software, designed primarily for touchscreen mobile devices such as smartphones and tablets. Android is developed by a consortium of developers known as the Open Handset Alliance, with the main contributor and commercial marketer being Google.[10]，引自[WIKIPEDIA](https://en.wikipedia.org/wiki/Android_(operating_system))


#### 概述
linux的进程基本都是通过fork而来，`init`进程作为天字1号进程，其实`idle`进程才是万物始祖，其启动是通过汇编语言实现的，作为天字0号进程，启动（fork）了`init`和`kthread`进程，一个是用户空间进程的头，另一个是内核进程头。就这样把自己的权利分配了，自己作为太上皇。
我们知道android 系统基于linux内核，严格意义上就是一个`linux`系统，只不过对上层进行了封装，用户不直接面对，`runtime`也就是虚拟机作为java代码的运行环境，其本身其实就是一个c++写的程序，这就是为何有了`jni`，其实就是java代码通过调用`native`方法，通过自身的运行环境`jvm`传递给了`native`层。我们常说`虚拟机`，他为撒字是`虚`的，为何’java一次编译，处处运行‘，仔细一想有着千丝万缕的关系。
##### bootRom
当电源按下，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后执行。

##### bootLoader

##### idle进程启动
辗转多个历程（后续再细究），来到，汇编语句：[msm/arch/arm64/kernel/head.S](https://android.googlesource.com/kernel/msm/+/refs/tags/android-8.0.0_r0.15/arch/arm64/kernel/head.S)
        
	...
	mov	x29, #0
	b	start_kernel
	...

由此进入c语言的世界[msm/init/main.c](https://android.googlesource.com/kernel/msm/+/refs/tags/android-8.0.0_r0.15/init/main.c)

	static noinline void __init_refok rest_init(void)
{
	int pid;
	const struct sched_param param = { .sched_priority = 1 };
	rcu_scheduler_starting();
	/*
	 * We need to spawn init first so that it obtains pid 1, however
	 * the init task will end up wanting to create kthreads, which, if
	 * we schedule it before we create kthreadd, will OOPS.
	 */
	kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);
	numa_default_policy();
	pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);
	rcu_read_lock();
	kthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);
	rcu_read_unlock();
	sched_setscheduler_nocheck(kthreadd_task, SCHED_FIFO, &param);
	complete(&kthreadd_done);
	/*
	 * The boot idle thread must execute schedule()
	 * at least once to get things moving:
	 */
	init_idle_bootup_task(current);
	schedule_preempt_disabled();
	/* Call into cpu_idle with preempt disabled */
	cpu_startup_entry(CPUHP_ONLINE);
	}

主要就是调用`kernel_thread`方法生成`init`、`ktreadadd`进程。
进入[msm/kernel/fork.c](https://android.googlesource.com/kernel/msm/+/refs/tags/android-8.0.0_r0.15/kernel/fork.c)`kernel_thread`方法:

	/*
 * Create a kernel thread.
 */
pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
{
	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, (unsigned long)fn,
		(unsigned long)arg, NULL, NULL);
	}

再进入`do-fork`方法：

	/*
 *  Ok, this is the main fork-routine.
 *
 * It copies the process, and if successful kick-starts
 * it and waits for it to finish using the VM if required.
 */
long do_fork(unsigned long clone_flags,
	      unsigned long stack_start,
	      unsigned long stack_size,
	      int __user *parent_tidptr,
	      int __user *child_tidptr)
{
	struct task_struct *p;
	int trace = 0;
	long nr;
	/*
	 * Do some preliminary argument and permissions checking before we
	 * actually start allocating stuff
	 */
	if (clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) {
		if (clone_flags & (CLONE_THREAD|CLONE_PARENT))
			return -EINVAL;
	}
	/*
	 * Determine whether and which event to report to ptracer.  When
	 * called from kernel_thread or CLONE_UNTRACED is explicitly
	 * requested, no event is reported; otherwise, report if the event
	 * for the type of forking is enabled.
	 */
	if (!(clone_flags & CLONE_UNTRACED)) {
		if (clone_flags & CLONE_VFORK)
			trace = PTRACE_EVENT_VFORK;
		else if ((clone_flags & CSIGNAL) != SIGCHLD)
			trace = PTRACE_EVENT_CLONE;
		else
			trace = PTRACE_EVENT_FORK;
		if (likely(!ptrace_event_enabled(current, trace)))
			trace = 0;
	}
	p = copy_process(clone_flags, stack_start, stack_size,
			 child_tidptr, NULL, trace);
	/*
	 * Do this prior waking up the new thread - the thread pointer
	 * might get invalid after that point, if the thread exits quickly.
	 */
	if (!IS_ERR(p)) {
		struct completion vfork;
		struct pid *pid;
		trace_sched_process_fork(current, p);
		pid = get_task_pid(p, PIDTYPE_PID);
		nr = pid_vnr(pid);
		if (clone_flags & CLONE_PARENT_SETTID)
			put_user(nr, parent_tidptr);
		if (clone_flags & CLONE_VFORK) {
			p->vfork_done = &vfork;
			init_completion(&vfork);
			get_task_struct(p);
		}
		wake_up_new_task(p);
		/* forking complete and child started to run, tell ptracer */
		if (unlikely(trace))
			ptrace_event_pid(trace, pid);
		if (clone_flags & CLONE_VFORK) {
			if (!wait_for_vfork_done(p, &vfork))
				ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);
		}
		put_pid(pid);
	} else {
		nr = PTR_ERR(p);
	}
	return nr;
	}

具体实现......
好，我们进入init.cpp

在init中做了一些事情，我们关注的是解析`Zygote.rc`文件，解析之后生成`Zygote`进程，java世界进程的鼻祖。
